import pandas as pd
import requests
import json
from scipy.spatial.distance import cosine
import os
from openai import OpenAI

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

# Function to generate an embedding using OpenAI's API
def generate_embedding(text, api_key):
    response = requests.post(
        "https://api.openai.com/v1/embeddings",
        headers={"Authorization": f"Bearer {api_key}"},
        json={"input": text, "model": "text-embedding-ada-002"}
    )
    response.raise_for_status()
    # Assuming the API returns the embedding directly under 'data' then 'embedding'
    embedding = response.json()['data'][0]['embedding']
    return embedding

# Function to calculate cosine similarity (smaller values indicate greater similarity)
def calculate_cosine_similarity(vec1, vec2):
    cosine_dist = cosine(vec1, vec2)
    cosine_similarity_score = 1 - cosine_dist
    return cosine_similarity_score
# Function to extract the actual embedding vector from the JSON-like string
import json

def query_chatgpt(prompt, api_key):
        background_info = "" #this can be used to provide context to the chatbot
        prompt = f"{background_info}\nUser: {user_input}"
        completion = client.chat.completions.create(
            messages=[
                {
                    "role": "user",
                    "content": prompt, 
                }
            ],
            model="gpt-3.5-turbo",
        )
        chatgpt_answer = completion.choices[0].message.content + " *answer generated by ChatGPT*"
        return chatgpt_answer

def extract_embedding(embedding_str):
    try:
        # Directly parse the JSON string
        embedding_dict = json.loads(embedding_str)
    except json.JSONDecodeError:
        # If there's a JSONDecodeError, it might be due to improper double quote wrapping.
        # Attempt to fix common formatting issues and retry parsing.
        # Note: This step might not be necessary if the JSON is properly formatted.
        fixed_str = embedding_str.replace("'", '"')
        embedding_dict = json.loads(fixed_str)
    
    # Navigate through the parsed JSON structure to extract the embedding list
    # Adjust the path based on your JSON structure
    embedding_vector = embedding_dict['data'][0]['embedding']
    return embedding_vector

# Set a threshold for cosine similarity
SIMILARITY_THRESHOLD = 0.8  # Experiment to find the best value

# Generate Embedding for User Input
user_input = "write a 3 line python code"
api_key = os.getenv("OPENAI_API_KEY")  # Use your actual API key
user_embedding = generate_embedding(user_input, api_key)

# Load Saved Embeddings and Parse Them
df_embeddings = pd.read_csv("C:/Users/Dan's PC/Desktop/tinyWeatherSet_with_embeddings.csv")
df_embeddings['ParsedEmbedding'] = df_embeddings['Embedding'].apply(extract_embedding)

# Calculate cosine similarity between user input embedding and each saved embedding
similarities = df_embeddings['ParsedEmbedding'].apply(lambda emb: calculate_cosine_similarity(user_embedding, emb))
df_embeddings['Similarity'] = similarities  # Add similarities to the DataFrame

# Sort by similarity and get the top 3 matches
sorted_embeddings = df_embeddings.sort_values(by='Similarity', ascending=False)
top_3_matches = sorted_embeddings.head(3)

# Check if the highest similarity score meets the threshold
if top_3_matches.iloc[0]['Similarity'] >= SIMILARITY_THRESHOLD:
    # If top matches are close enough, prepare a response with them
    response = "Top 3 matching providers and services based on your input:\n"
    for index, row in top_3_matches.iterrows():
        response += f"ProviderID: {row['ProviderID']}, Service: {row['Service']}, Similarity: {row['Similarity']:.2f}\n"
else:
    # If no embedding is close enough, fallback to querying the OpenAI GPT
    response = query_chatgpt(user_input, api_key)  # Placeholder for the actual function call

print(response)